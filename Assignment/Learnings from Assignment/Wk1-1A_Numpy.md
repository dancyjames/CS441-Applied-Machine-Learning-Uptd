# %matplotlib inline command 
The %matplotlib inline command is a special directive in Jupyter notebooks that tells the notebook to display matplotlib plots inline, directly within the notebook output cells.

When you run this command:

The plots generated by matplotlib will be displayed below the code cells.
You don't need to call plt.show() explicitly to see the plots.Â 

# Why this code goes infinite
```
fp = 0
while fp != 1:
    fp = fp + 0.1
```

> Due to how floating-point numbers are represented in computers, the value of fp might never be exactly 1.0, 


# Notes Summary
- you should not try to check for exact equivalence (==) with floats. Instead, you can measure approximate equivalence.
- Associative and Distributive property will not work
>> 1.  x, y, z, (x + y) + z == x + (y + z) = FALSE
>> 2. a, b, c, a * (b + c) == a * b + a * c = FALSE

**Create Array**
```
np.array([1,2,3])
```

**Arithment operation**
```
a_mul_b = a * b
a_plus_b = a + b
a_minus_b = a - b
a_div_b = a / b
a_pow_b = a ** b
```

**Array Operation**
![alt text](image.png)

**Diagonal matrix and multiplication**
> np.diag(a)
> a_diag @ A (@ is shortcut for multiplication)

*Example*
![alt text](image-1.png)

**Broadcasting Concept**
Reshape
![alt text](image-2.png)
Reshape with -1
![alt text](image-3.png)

**reshape().shape()**
Gives the shape of the array
![alt text](image-4.png)

*Note!!!*
![alt text](image-8.png)
*Use Shape[0] to get shape*
![alt text](image-9.png)
**Matrix Multiplication (@) vs.  Dot matrix (*)**
### Matrix Multiplicaation
> Rule
 >> the number of columns in the first matrix must equal the number of rows in the second matrix.
 *Example*
 ![alt text](image-5.png)

 > This is achieved by "@"
### Element wise Multiplication
> Rule
> > Both arrays must have the same shape or be compatible for broadcasting.
*Sample*
![alt text](image-6.png)

## Numpy Autoscale to fit operations
![alt text](image-7.png)

## Power
Use "**"

## To multiple all elements of one array
```
prod(array)
```

## Square root (Geom_mean)
To achieve
![alt text](image-10.png)
Do..
![alt text](image-11.png)

## Exponents (Multiple to log addition)
![alt text](image-12.png)

> - Multiplication in log is addition
> Square"N" root convert to exp (mean)
From 
![alt text](image-17.png)
to
![alt text](image-16.png)

![alt text](image-18.png)
- Step 3 converts logarithm back to exp.

**What is exp?**
![alt text](image-13.png)
*Sample*
![alt text](image-14.png)

---
# ELEMENTS ADJUSTING/MANIPULATE!
#  Arange
create array starting with "0" and extends to the limit
## ASK:
![alt text](image-19.png)

**NOTE**
- use arrange to create array
- add one as arange starts with 0. use this to create row multipliers and column divisors
- for row multipliers, you should have one column and for column divisors , you should have one row. So use "-1"
  

---
## Basic Indexing
**Step1:Shuffle and setup an array**
![alt text](image-20.png)
**Solution**
![alt text](image-21.png)
*Note*
1. "-5" takes from the last 5 posiitons
## Shuffle
np.random.seed(1)
A = np.arange(100)
np.random.shuffle(A)  # shuffle in place

----